---
title: "Data Analytics and Visualizations in R - Exercises"
output:
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
    number_sections: true
    theme: lumen
    highlight: tango
    code_folding: show
    keep_md: true
---

```{r}
library(ggplot2)
library(data.table)
library(magrittr)
library(tidyr)
```


# Basic R Data Structures

***

## Types

What are the scalar types in R?

```{r}
# Scalars are just vectors of length one
```


## Weirdness of R

What is the major difference between atomic vectors and lists? How can you turn a list into an atomic vector?

In order to check if an object is of a certain type you can use `is.[type](object)` ,e.g. `is.integer(object)`

Can you use the `is.vector()` function to understand whether a data structure is a vector? If
not, what are the functions that you can use for this purpose?

```{r}
# Atomic vectors can contain elements of the same type. The elements of a list 
# can have different types.

# Yes, we can use the `is.vector()` function to understand is the structure is a 
# vector. It will return TRUE or FALSE.

a <- list(c(1,2,3), "bla", TRUE)
print(a)
is.vector(a)

# Best response: If possible you should use type specific coercions like 
# `as.numeric()` or `as.character()`. But since lists are heterogenous, this 
# might not work. A more general function is `unlist()`,  which returns the list 
# into a vector of the most general type. Notice this difference:

a <- list(c(1,2,3), "bla", TRUE)
unlist(a)
as.character(a)

# Generally you can, but here comes the weird part: `is.vector()` will only return `TRUE` if the vector has 
# no attributes `names`. Therefore more specific functions like `is.atomic()` or `is.list()` functions should 
# be used to test if an object is actually atomic vectoror a list
```


## Atomic Vector Concatenation

What happens when you try to generate an atomic vector with `c()`which is composed of different types of elements? What is the `mean()` 
of a logical vector?

```{r}
# When we attempt to combine different types they will be coerced to the most 
# flexible type. Types from least to most flexible are: logical, integer, double
#  and character.

str(c("a", 1)) # 1 corced to char

# As TRUE is encoded as 1 and FALSE as 0, the mean is the number of TRUEs 
# devided by the vector length.
mean(c(TRUE, FALSE,FALSE))
```


## Vector Concatenation

Compare X and Y where X and Y are defined as follows. What is the difference?

```{r}
x <- list(list(1,2), c(3,4))
y <- c(list(1,2), c(3,4))
```

```{r}
# Answer
# X will combine seveal lists into one. Given a combination of atomic vectors 
# and lists, y will coerce the vectors to lists before combining them.
str(x)
str(y)
```

## From Vectors to `data.frames`

First, create three named numeric vectors of size 10, 11 and 12 respectively in the following
manner:

* One vector with the “colon” approach: *from:to*
* One vector with the `seq()` function: *seq(from, to)*
* And one vector with the `seq()` function and the by argument: *seq(from, to, by)*

For easier naming you can use the vector `letters` or `LETTERS` which contain the latin alphabet
in small and capital, respectively. In order to select specific letters just use e.g. `letters[1:4]`
to get the first four letters. 
Check their types. What is the outcome? Where do you think does the difference come from?

Then combine all three vectors in a list. Check the attributes of the vectors and the list.
What is the difference and why?

Finally coerce the list to a `data.frame` with `as.data.frame()`. Why does it fail and how can we fix it? 
What happend to the names?

Hint: If list elements have no names, we can access them with the double brackets and an
index, e.g. `my_list[[1]]`

```{r}
# Answer

# A. create vectors
aa <- 1:10
names(aa) <- letters[aa]
aa
bb <- seq(1, 11)
names(bb) <- letters[bb]
bb
cc <- seq(1, 12, by=1)
names(cc) <- letters[cc]

typeof(aa)
typeof(bb)
typeof(cc)

# B. Combine all three vectors in a list
 
my_list <- list(aa, bb, cc)
my_list
attributes(aa)
attributes(bb)
attributes(cc)
attributes(my_list)

# C. Coerce to data.frames

# my_df <- as.data.frame(my_list)# fails

# Fixing the length
my_list[[1]] <- c(my_list[[1]], NA, NA)
my_list[[2]] <- c(my_list[[2]], NA)

my_df <- as.data.frame(my_list)
names(my_df) <- LETTERS[1:3]
my_df
```

## Attributes
Take again our `data.frame` from Question 5.

* Change the row names and the column names of the `data.frame` to capital letters (or small letters, if they 
are already capital.
* Change the `class` attribute to *list*. What happens?
* Change it now to any name you like. What happens now? What happens if you remove the class attribute

```{r}
# Answer
# A. One possible way through attributes

attributes(my_df)
attr(my_df, "names") <- letters[1:3]
attr(my_df, "row.names") <- LETTERS[1:12]
my_df

# Or through accessor functions

names(my_df) <- LETTERS[1:3]
row.names(my_df) <- letters[1:12]
my_df

# B. 

attr(my_df, "class") <- "list"
my_df

# Answer - the data.frame coerced to a list

# C
attr(my_df, "class") <- "Batman"
my_df

# Answer - Nothing changes
```

## Factors

* What is the difference between a Factor and a Vector?
* Create a vector of length 30 with three levels *Rita Repulsa, Lord Zedd* and *Rito Revolto* and equal length for each level
* What happens if you replace the second element of the vector with *Shredder*

```{r}
# Answer
# A. A factor is a vector that can contain only predefined values, and is used 
# to store categorical data. It is stored as an integer with a character string 
# associated with each integer value

# B.

x <- gl(n=3, k=10, length=30, labels=c("Rita Repulsa", "Lord Zedd", "Rito Revolto"))
str(x)
levels(x)
attributes(x)

# C
x[2] <- "Shredder"
# It doesn't work. We get the error 'NA generated'
```

## More fun with factors

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
f2 <- rev(factor(letters))
f3 <- factor(letters, levels = rev(letters))
```

The function `rev` reverses the order of an orderable object. What is the difference between f1, f2 and f3? Why?

```{r}
# Answer
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

# f1 goes from a to z and when we apply the levels(f1), z will become 1 and a=26

f2 <- rev(factor(letters))

# f2 goes from z to a. but the levels are not changed.

f3 <- factor(letters, levels = rev(letters))

# f3 goes from a - z, but the underlying encoding goes from z = 1 to a = 26.  
# We create the vector with the letters a to z BUT the mapped integer structure 
# 26 to 1. Hence the levels but not the vector are reversed

f3

# Reversing f3 will give f1

rev(f3)

```

## Creating data.frames

Create a data.frame with 26 rows like this: Only the first and the last six rows are shown.
Hint: Instead of the workaround with list you can also use simply `data.frame(column_name
= column_vector, ...)`

```{r}
aa <- seq(1:26)
bb <- seq(from=4, to=4*26, by=4)
cc <- rep(seq(1, 26, 2), each=2)
df <- data.frame(V1 = aa, V2 = bb, V3 = letters[cc])
head(df)
tail(df)
```

## Combining `data.frames`

Now take the previous data.frame from Question 10 and reproduce the following `data.frame`.
Only the first and the last six rows are shown
**Hint:** In order to combine to data.frames by column you can use `cbind(df1, df2, ...)`

help(cbind)
```{r}
df[,1] <- NULL
dd <- rev(rep(seq(1, 26, 2), each = 2))
ee <- seq(0, 1.6, length.out = 26)
df2 <- data.frame(V4 = dd, V5 = ee)
binded_df <- cbind(df2, df)
head(binded_df)
tail(binded_df)
```

## Computation on data.frames

Create the data.frame *df* with `df <- as.data.frame(matrix(runif(9e6), 3e3, 3e3))`
This will create a data.frame with 3000 columns and rows and a total of 9mil values.

Now compute the sum of any row, then compute the sum of any column. Measure the time
for both operations. Why are the times different, although the size is the same?

* **Hint1:** The time is measured with the function `system.time(my_function_call())`, e.g: `system.time(mean(my_vector))`
* **Hint2:** The sum can be computed with the sum function `sum(my_vector)`
* **Hint2:** Columns and rows are selected by single brackets. Rows: `df[row_number,]`, Columns: `df[,col_number]`

```{r}
# Answer

df <- as.data.frame(matrix(runif(9e6), 3e3, 3e3))

# rows
system.time(res <- sum(df[1,]))
res

# columngs
system.time(res2 <- sum(df[,1]))
res2

# Look at the structure of the objects over which we are computing the sum
# Column
str(df[1,])

# Row
str(df[,1])

# As we can see the extracted column is a numeric vector. But the extracted
# row is a list. Under the hood the sum function is iterating in C/Fortran
# over the specific structure. Iterating over a native array of doubles is
# faster, than iterating over a structure, where at each position, the value
# has to be retrieved from an object possibly strored somewhere further away
# in memory.
```

## Missing Values

* If NA is just a placeholder for a missing value of the same type and Infinity is of type
double, why is Infinity plus NA not Infinity?

**Hint:**
```{r}
paste(paste(rep((Inf - Inf), 20), collapse = ""), "Batman!")
```

```{r}
# Answer:
# Because infinity is not a well defined number, but a concept with
# the type 'double' in R. Adding or subtracting any number from infinity
# will give infinity. However NA is placeholder for any value of the same
# type and therefore also for infinity. As infinity plus/minus infinity
# is not defined, adding NA to infinity can theoretically lead to
# Nan (not a number). Therefore Inf + NA will produce NA.

Inf + NA
Inf + 1
Inf - Inf
```

---

# Advanced R Data Structures and Mathematical Operations

## Basic data structures

How would you create a 3 by 4 matrix that contains the numbers 1 to 12 and then convert it into a data frame?

```{r}
# Answer

x <- matrix(1:12, 3,4)
x <- as.data.frame(x)
x
```

## 
Please use the data frame you created in the first question for the next 5 questions. 
How would you select the second row elements at second and fourth column ?

```{r}
x <- data.frame(matrix(1:12, 3, 4))
x[2, c(2,4)]
```

##
How would you assign zero to the elements at row 2 which are greater than 4?

```{r}
x <- data.frame(matrix(1:12, 3, 4))
x[2, x[2,]>4] <- 0
x
```

##
How do you set the rownames to “row1”, “row2”, “row3” and column names to “col1”, “col2”, “col3” and “col4” ?
(hint:use function “paste0”)

```{r}
x <- data.frame(matrix(1:12, 3, 4))
rownames(x) <- paste0("row", 1:3)
colnames(x) <- paste0("col", 1:4)
x
```

##
How do you assign 0 to all elements in columns “col3” and “col4” by using paste0 function ?

```{r}
x <- data.frame(matrix(1:12, 3, 4))
colnames(x) <- paste0("col", 1:4)
x[, paste0(0, 3:4)] <- 0
x
```

## `lapply()`
How do you get the numbers whose mod 2 is 0

* by using lapply() function 
* by subsetting the data frame directly?

```{r}
x <- data.frame(matrix(1:12), 3, 4)

lapply(x, function(a) a[(a %% 2) == 0])

x[x %% 2 == 0]
```

##
Considering `x <- c(“a”=1, “b”=2, “c”=3, “d”=4, “e”=5)`, show how to select the third and fifth elements of x by using
positive integers, negative integers, a logical vector, and a character vector.

```{r}
x <- c("a"=1, "b"=2, "c"=3, "d"=4, "e"=5)
x[c(3,5)]
x[-c(1,2,4)]
x[c(F,F,T,F,T)]
x[c("c", "e")]
```

##
Why are `vals[c(2, 5)]` and `vals[2, 5]` different where `vals <- outer(1:5, 1:5, FUN = “/”)`? How would you select fifth and
nineth elements of vals by the use of a matrix?

```{r}
vals <- outer(1:5, 1:5, FUN = "/")

# Because when you subset matrix with a vector, the 2d matrix behaves
# like a vector and vals[c(2, 5)] returns the elements at indices 2
# and 5 in column-major order. vals[2, 5] returns the element at row 2, column 5.

select <- matrix(ncol=2, byrow=TRUE, c(5,1,4,2))

vals[select]
```


##
Consider df <- data.frame(a=paste(“Point_”, 1:20), b=rep(1:4, each = 2, len = 20), c= seq(1,40,length.out = 20),
stringsAsFactors = F). Assign “Point_undefined” to column a of all rows of df where column b > 1 and column c > 21 ?
What is the reason of the different result that you get if you do the same operation with df being created with option
stringsAsFactors = T ?

##
Assume x <- matrix(1:20, ncol=2). What is the difference between x[1, , drop = T] and x[1, , drop = F]? Now let y <-
as.data.frame(x). What is the difference between y[,1] , y[[1]] and y[1]

##
What is the difference between x[“b”] <- list(NULL) and x[“b”] <- NULL where x <- list(a = c(1:5), b = c(12:15))?

## 
Assume you have a lookup table as lookup <- c(a = “sun”, b = “rain”, c=“wind”, u = NA). How would you generate
the weekly weather predictions c(“sun”,“sun”,“rain”, NA, “rain”, “rain”, “wind”) out of this lookup table?

##
Now assume the weather in winter lookup table is a data frame as below and we have the predictions for the next week as
stored in weeklyCast. How would you create “weeklyTable” by the use of rownames function? How would you create it by
the use of match function? How would you order the rows of lookup table by desc column?

##
Consider the bigDF data frame which has 1500 columns and rows. How would you select the even numbered columns
named such as “Column_2”, “Column_4”, etc.? How would you select all the columns other than column 76? How
would you assign 1 to 500 randomly selected diagonal indices? How can you retrieve the row and column indices of the
elements which has been assigned 1? How would you select rows where columns Column_1 or Column_2 are 1 by using
the subset() function?

##
Assume x <- 1:20 %% 2 == 0 and y <- 1:20 %% 5 == 0 . What are the indices of the elements that are True for both
x and y? What are the indices of the elements that are True for either x or y, or both?

# Data Import

## Flat File - Q1

A csv file has numbers as column names in the first row, i.e. IDs to randomize persons. Which
parameter of read.table() needs to be adjusted to read the column names as they are in the
csv?

```{r}
tmp_tidy_table <- "1_colname, 2_colname, 3_colname
3,4,5
a,b,c"
tmp_tidy_table
read.csv(text=tmp_tidy_table)

# Parameter `check.names`: a logical, tests for synatactically valid varaible 
# names

tidy_text_df <- read.csv(text=tmp_tidy_table, check.names = FALSE)
tidy_text_df
```


## Flat File - Q2

How to read the following table to have the `identical()` information as in `tidy_txt_df` from
question above?

```{r}
tmp_messy_table <- "# This line is just useless info

1_colname,2_colname,3_colname
3,4,5

a,b,c"
```

```{r}
# To have the identical information as in the previous table we have to check
# which lines are comments. We can do this with `comment.char` parameter.

messy_text_df <- read.csv(text = tmp_messy_table, comment.char = '#', check.names = F)
identical(messy_text_df, tidy_text_df)
```

## Flat File - Q3

Read the `hollywood.tsv` (not *.csv) file into a `data.table` R object. What is the problem with
`fread()`?

```{r}
file_holly_tab <- "extdata/hollywood.tsv"
holly <- as.data.table(read.delim(file_holly_tab), keep_row_names=T)
head(holly)
class(holly)

holly_data_table <- fread(file_holly_tab, skip=1)
class(holly_data_table)
head(holly_data_table)
holly_cn <- c("ID", colnames(read.delim(file_holly_tab, nrows= 1)))
holly_cn

# setnames(holly, holly_cn)
# head(holly)
# Difference between them: We can keep row_names. data.frame has no row_names.

```


## Flat File - Q4

Who was the oldest surviving passenger of the titanic accident (titanic.csv)? Tipp: `?subset`

```{r}
tit_df <- read.csv("extdata/titanic.csv")
head(tit_df)

survivor_name <- subset(tit_df, survived==1 & age==max(age, na.rm = T), name)
survivor_age <- subset(tit_df, survived==1 & age==max(age, na.rm = T), age)

survivor_name
survivor_age
```


## Excel Questions - Q1

Read only Name, Type and Total columns for only the first 10 pokemons of the pokemon.xlsx
file.

## Excel Question - Q2

Which athlete won most bronze medals?

## Excel Question - Q3

Are the columns Gender and Event_gender consistent?

## Excel Question - Q4

Which country won most medals? Which country has the highest ratio of silver medals? Use
the data in the country summary sheet starting at row 147.

## Excel Questions

Which countries did participate, but without winning medals?

## XML - Q1

Load the XML document plant_catalog.xml. Use XPath and DOM functions to find out all
unique element names in the document.

Get all plants of zone 4 and transform the data into an R list.

## XML - Q2

Read the tables HTML tables from the TUM website of dates for the winter term
https://www.tum.de/en/studies/application-and-acceptance/dates-and-deadlines/
dates-and-deadlines-17/ into your workspace.
When are the Christmas holidays?

## JSON - Q1

Read the countries.json file. Which countries have common border with Jordan? Which
country has the most neighbors?

## JSON - Q2

Read this JSON file about projects funded by the world bank: world_bank.json.zip. Be aware,
you might need to add syntax elements like “[” and “,” to convert the file into textbook
JSON format, i.e. readable by R. What was the most expensive project?

## SQL - Q1

Use the extdata/Northwind.sl3 SQLite data base and retrieve a table that lists for all
customers (name of the company, name of the contact person and city) all the products
(name of the product) that they ordered. How many rows does this table have? Display the
first 5 rows.

# Grammar of graphics and plotting I

## Q1

Match each chart type with the relationship it shows best.

1. shows distribution and quantiles, especially useful when comparing distributions.
2. highlights individual values, supports comparison and can show rankings or deviations categories and totals
3. shows overall changes and patterns, usually over intervals of time
4. shows relationship between two continues variables.

Options: bar chart, line chart, scatterplot, boxplot

```{r}
# Answer
# 
# 1 -> boxplot
# 2 -> bar chart
# 3 -> line chart
# 4. -> scatterplot
```

## Q2
`Iris` is a classical dataset in machine learning literature, was first introduced by R.A. Fisher
in his 1936 paper. Load the iris data into your R environment. What is the dimension of the
dataset and what kind of data type does each column has?

```{r}
dim(iris)
head(iris)
```

## Q3
How are the lengths and widths of sepals and petals distributed? How would you visualize
them. Describe what you see. Hint: `facet_wrap(~variable)`.

```{r}
iris_melt <- melt(iris, id.var=c("Species"))
iris_melt
iris_melt %>% 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_wrap(~variable)
```

## Q4
Vary the number of bins in the above histogram. Describe what you see

```{r}
#Answer: With very few bins, we cannot show the bimodal distribution correctly

iris_melt %>%
  ggplot(aes(value)) +
  geom_histogram(bins=5) +
  facet_wrap(~variable)
```


# Datacamp

## `ggplot2` on Datacamp
```{r}
str(mtcars)
ggplot(mtcars, aes(x = cyl, y = mpg)) +
  geom_point()

#Stellar scatterplotting! Notice that ggplot2 treats cyl as a factor. 
#This time the x-axis does not contain variables like 5 or 7, only the values 
#that are present in the dataset.
```

```{r}
# Change the command below so that cyl is treated as factor
ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_point()
```


## Exploring ggplot2, part 3

We'll use several datasets throughout the courses to showcase the concepts discussed in the videos. In the previous exercises, you already got to know mtcars. Let's dive a little deeper to explore the three main topics in this course: The data, aesthetics, and geom layers.

The mtcars dataset contains information about 32 cars from 1973 Motor Trend magazine. This dataset is small, intuitive, and contains a variety of continuous and categorical variables.

You're encouraged to think about how the examples and concepts we discuss throughout these data viz courses apply to your own data-sets!

### Instructions

* `ggplot2` has already been loaded for you. Take a look at the first command. It plots the mpg (miles per galon) against the weight (in thousands of pounds). You don't have to change anything about this command.

* In the second call of ggplot() change the color argument in aes() (which stands for aesthetics). The color should be dependent on the displacement of the car engine, found in disp.

* In the third call of ggplot() change the size argument in aes() (which stands for aesthetics). The size should be dependent on the displacement of the car engine, found in disp.


```{r}
# A scatter plot has been made for you
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point()

# Replace ___ with the correct column
ggplot(mtcars, aes(x = wt, y = mpg, color = disp)) +
  geom_point()

# Replace ___ with the correct column
ggplot(mtcars, aes(x = wt, y = mpg, size = disp)) +
  geom_point()

```

## Understanding Variables

In the previous exercise you saw that `disp` can be mapped onto a color gradient or onto a continuous size scale.

Another argument of `aes()` is the shape of the points. There are a finite number of shapes which ggplot() can automatically assign to the points. However, if you try this command in the console to the right:


```{r}
#ggplot(mtcars, aes(x = wt, y = mpg, shape = disp)) +
#  geom_point()

```

It gives an error. What does this mean?

```{r}
# Error: A continuous variable can not be mapped to shape
# 
# Correct. The error message 'A continuous variable can not be mapped to shape', 
# means that shape doesn't exist on a continuous scale here.
```

## Exploring ggplot2, part 4

The `diamonds` data frame contains information on the prices and various metrics of 50,000 diamonds. Among the variables included are `carat` (a measurement of the size of the diamond) and price. For the next exercises, you'll be using a subset of 1,000 diamonds.

Here you'll use two common geom layer functions: `geom_point()` and `geom_smooth()`. We already saw in the earlier exercises how these are added using the + operator.

### Instructions

* Explore the diamonds data frame with the `str()` function.
* Use the `+` operator to add `geom_point()` to the first `ggplot()` command. This will tell `ggplot2` to draw points on the plot.
* Use the `+` operator to add `geom_point()` and `geom_smooth()`. These just stack on each other! `geom_smooth()` will draw a smoothed line over the points.

```{r}
# Explore the diamonds data frame with str()
str(diamonds)

# Add geom_point() with +
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()


# Add geom_point() and geom_smooth() with +
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth()

# Lovely layering! If you had executed the command without adding a +, it would 
# produce an error message 'No layers in plot' because you are missing the third 
# essential layer - the geom layer.

```

## Exploring ggplot2, part 5

The code for last plot of the previous exercise is available in the script on the right. It builds a scatter plot of the diamonds dataset, with carat on the x-axis and price on the y-axis. geom_smooth() is used to add a smooth line.

With this plot as a starting point, let's explore some more possibilities of combining geoms.

### Instructions

* Plot 2 - Copy and paste plot 1, but show only the smooth line, no points.
* Plot 3 - Show only the smooth line, but color according to clarity by placing the argument color = clarity in the aes() function of your ggplot() call.
* Plot 4 - Draw translucent colored points.
  * Copy the ggplot() command from plot 3 (with clarity mapped to color).
  * Remove the smooth layer.
  * Add the points layer back in.
  * Set alpha = 0.4 inside geom_point(). This will make the points 40% transparent.
  
```{r}
# 1 - The plot you created in the previous exercise
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth()

# 2 - Copy the above command but show only the smooth line
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_smooth()


# 3 - Copy the above command and assign the correct value to col in aes()
ggplot(diamonds, aes(x = carat, y = price, color=clarity)) +
  geom_smooth()



# 4 - Keep the color settings from previous command. Plot only the points with argument alpha.
ggplot(diamonds, aes(x = carat, y = price, color=clarity)) +
  geom_point(alpha=0.4)

## Smooth work! `geom_point() + geom_smooth()` is a common combination.
```

## Understanding the grammar, part 1

Here you'll explore some of the different grammatical elements. Throughout this course, you'll discover how they can be combined in all sorts of ways to develop unique plots.

In the following instructions, you'll start by creating a ggplot object from the diamonds dataset. Next, you'll add layers onto this object to build beautiful & informative plots.

### Instructions

Define the data (diamonds) and aesthetics layers. Map carat on the x axis and price on the y axis. Assign it to an object: dia_plot.

Using +, add a geom_point() layer (with no arguments), to the dia_plot object. This can be in a single or multiple lines.

Note that you can also call aes() within the geom_point() function. Map clarity to the color argument in this way.

```{r}
# Create the object containing the data and aes layers: dia_plot
dia_plot <- ggplot(diamonds, aes(x = carat, y = price))

# Add a geom layer with + and geom_point()
dia_plot + geom_point()

# Add the same geom layer, but with aes() inside
dia_plot + geom_point(aes(color = clarity))

# Remarkable plot recyling! Notice how you can store the plot as a ggplot object 
# that you can use later on to add other layers; that's pretty convenient!
```

## Understanding the grammar, part 2

Continuing with the previous exercise, here you'll explore mixing arguments and aesthetics in a single geometry.

You're still working on the diamonds dataset.

### Instructions

1 - The dia_plot object has been created for you.
2 - Update dia_plot so that it contains all the functions to make a scatter plot by using geom_point() for the geom layer. Set alpha = 0.2.
3 - Using +, plot the dia_plot object with a geom_smooth() layer on top. You don't want any error shading, which can be achieved by setting the se = FALSE in geom_smooth().
4 - Modify the geom_smooth() function from the previous instruction so that it contains aes() and map clarity to the col argument.

```{r}
# 1 - The dia_plot object has been created for you
dia_plot <- ggplot(diamonds, aes(x = carat, y = price))

# 2 - Expand dia_plot by adding geom_point() with alpha set to 0.2
dia_plot <- dia_plot +geom_point(alpha=0.2)

# 3 - Plot dia_plot with additional geom_smooth() with se set to FALSE
dia_plot + geom_smooth(se = FALSE)

# 4 - Copy the command from above and add aes() with the correct mapping to 
# geom_smooth()
dia_plot + geom_smooth(aes(col = clarity), se = FALSE)

# Bravo! To set a property of a geom to a single value, pass it as an argument. 
# To give the property different values for each row of data, pass it as an 
# aesthetic.

```

## Chapter 2
## base package and ggplot2, part 1 - plot

These courses are about understanding data visualization in the context of the grammar of graphics. To gain a better appreciation of ggplot2 and to understand how it operates differently from base package, it's useful to make some comparisons.

In the video, you already saw one example of how to make a (poor) multivariate plot in base package. In this series of exercises you'll take a look at a better way using the equivalent version in ggplot2.

First, let's focus on base package. You want to make a plot of mpg (miles per gallon) against wt (weight in thousands of pounds) in the mtcars data frame, but this time you want the dots colored according to the number of cylinders, cyl. How would you do that in base package? You can use a little trick to color the dots by specifying a factor variable as a color. This works because factors are just a special class of the integer type.

### Instructions

Using the base package plot(), make a scatter plot with `mtcars$wt` on the x-axis and `mtcars$mpg` on the y-axis, colored according to `mtcars$cyl` (use the col argument). You can specify data = but you'll just do it the long way here.
Add a new column, fcyl, to the mtcars data frame. This should be cyl converted to a factor.
Create a similar plot to instruction 1, but this time, use fcyl (which is cyl as a factor) to set the col.

```{r}
# Plot the correct variables of mtcars
plot(mtcars$wt, mtcars$mpg, col = mtcars$cyl)

# Change cyl inside mtcars to a factor
mtcars$fcyl <- as.factor(mtcars$cyl)

# Make the same plot as in the first instruction
plot(mtcars$wt, mtcars$mpg, col=mtcars$fcyl)

# It's all about that base! Recall that under-the-hood, factors are simply 
# integer type vectors, so the colors in the second plot are 1, 2, and 3. 
# In the first plot the colors were 4, 6, and 8.
```

## base package and ggplot2, part 2 - lm

If you want to add a linear model to your plot, shown right, you can define it with lm() and then plot the resulting linear model with abline(). However, if you want a model for each subgroup, according to cylinders, then you have a couple of options.

You can subset your data, and then calculate the lm() and plot each subset separately. Alternatively, you can vectorize over the cyl variable using lapply() and combine this all in one step. This option is already prepared for you.

The code to the right contains a call to the function lapply(), which you might not have seen before. This function takes as input a vector and a function. Then lapply() applies the function it was given to each element of the vector and returns the results in a list. In this case, lapply() takes each element of `mtcars$cyl` and calls the function defined in the second argument. This function takes a value of mtcars$cyl and then subsets the data so that only rows with cyl == x are used. Then it fits a linear model to the filtered dataset and uses that model to add a line to the plot with the abline() function.

Now that you have an interesting plot, there is a very important aspect missing - the legend!

In base package you have to take care of this using the legend() function. This has been done for you in the predefined code.

### Instructions

Fill in the lm() function to calculate a linear model of mpg described by wt and save it as an object called carModel.
Draw the linear model on the scatterplot.
Write code that calls abline() with carModel as the first argument. Set the line type by passing the argument lty = 2.
Run the code that generates the basic plot and the call to abline() all at once by highlighting both parts of the script and hitting control/command + enter on your keyboard. These lines must all be run together in the DataCamp R console so that R will be able to find the plot you want to add a line to.
Run the code already given to generate the plot with a different model for each group. You don't need to modify any of this.

```{r}
# Use lm() to calculate a linear model and save it as carModel
carModel <- lm(mpg ~ wt, data = mtcars)

# Basic plot
mtcars$cyl <- as.factor(mtcars$cyl)
plot(mtcars$wt, mtcars$mpg, col = mtcars$cyl)

# Call abline() with carModel as first argument and set lty to 2
abline(carModel, lty = 2)

# Plot each subset efficiently with lapply
# You don't have to edit this code
plot(mtcars$wt, mtcars$mpg, col = mtcars$cyl)
lapply(mtcars$cyl, function(x) {
  abline(lm(mpg ~ wt, mtcars, subset = (cyl == x)), col = x)
  })

# This code will draw the legend of the plot
# You don't have to edit this code
legend(x = 5, y = 33, legend = levels(mtcars$cyl),
       col = 1:3, pch = 1, bty = "n")

# Phew! Notice how the legend had to be set manually. In general, ggplot2 makes 
# it easier to polish plots compared to base 
```

## base package and ggplot2, part 3

In this exercise you'll recreate the base package plot in ggplot2.

The code for base R plotting is given at the top. The first line of code already converts the cyl variable of mtcars to a factor.

### Instructions

Plot 1: add geom_point() in order to make a scatter plot.

Plot 2: copy and paste Plot 1

Add a linear model for each subset according to cyl by adding a geom_smooth() layer

Inside this geom_smooth(), set method to "lm" and se to FALSE.

Note: geom_smooth() will automatically draw a line per cyl subset. It recognizes the groups you want to identify by color in the aes() call within the ggplot() command.

Plot 3: copy and paste Plot 2

Plot a linear model for the entire dataset, do this by adding another geom_smooth() layer

Set the group aesthetic inside this geom_smooth() layer to 1. This has to be set within the aes() function.

Set method to "lm", se to FALSE and linetype to 2. These have to be set outside aes() of the geom_smooth().

Note: the group aesthetic will tell ggplot() to draw a single linear model through all the points.

### HINT

For Plot 1, you have to add geom_point() to the ggplot() command without any arguments. Use +.
For Plot 2, you should expand the previous ggplot() command with a geom_smooth() layer. The arguments you have to set are described in the instructions. You don't have to add anything to draw a line per cyl group, ggplot() will do this automatically, as described in the instructions.
For Plot 3, expand the previous ggplot() command with another geom_smooth() layer. This time the first argument should be an aes() mapping with group = 1. Don't forget to set the linetype as defined in the instructions. This is an argument of geom_smooth(), not of aes(). method and se should be set as in the previous command.

```{r}
# Convert cyl to factor (don't need to change)
mtcars$cyl <- as.factor(mtcars$cyl)

# Example from base R (don't need to change)
plot(mtcars$wt, mtcars$mpg, col = mtcars$cyl)
abline(lm(mpg ~ wt, data = mtcars), lty = 2)
lapply(mtcars$cyl, function(x) {
  abline(lm(mpg ~ wt, mtcars, subset = (cyl == x)), col = x)
  })
legend(x = 5, y = 33, legend = levels(mtcars$cyl),
       col = 1:3, pch = 1, bty = "n")

# Plot 1: add geom_point() to this command to create a scatter plot
ggplot(mtcars, aes(x = wt, y = mpg, col = cyl)) +
  geom_point()

# Plot 2: include the lines of the linear models, per cyl
ggplot(mtcars, aes(x = wt, y = mpg, col = cyl)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

# Plot 3: include a lm for the entire dataset in its whole
ggplot(mtcars, aes(x = wt, y = mpg, col = cyl)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  geom_smooth(aes(group = 1), method = "lm", se = FALSE, linetype = 2)
```


## Plotting the ggplot2 way
In the video, Rick showed you different ggplot2 calls to plot two groups of data onto the same plot:

* Option 1
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point() +
  geom_point(aes(x = Petal.Length, y = Petal.Width), col = "red")

* Option 2
ggplot(iris.wide, aes(x = Length, y = Width, col = Part)) +
  geom_point()
Which one is preferable? Both iris and iris.wide are available in the workspace, so you can experiment in the R Console straight away!

```{r}
# Correct! You're starting to grasp the ggplot2 philosophy; that's great!
```

## Variables to visuals, part 1

So far you've seen four different forms of the iris dataset: iris, iris.wide, iris.wide2 and iris.tidy. Don't let all these different forms confuse you! It's exactly the same data, just rearranged so that your plotting functions become easier.

To see this in action, consider the plot in the graphics device at right. Which form of the dataset would be the most appropriate to use here?

### Instructions

Look at the structures of iris, iris.wide and iris.tidy using str().
Fill in the ggplot function with the appropriate data frame and variable names. The variable names of the aesthetics of the plot will match the ones you found using the str() command in the previous step.

```{r}
# Iris library

iris$Flower <- 1:nrow(iris)

iris.wide <- iris %>%
  gather(key, value, -Species, -Flower) %>%
  separate(key, c("Part", "Measure"), "\\.") %>%
  spread(Measure, value)

iris.tidy <- iris %>%
  gather(key, Value, -Species) %>%
  separate(key, c("Part", "Measure"), "\\.")
```


```{r}
# Consider the structure of iris, iris.wide and iris.tidy (in that order)
str(iris)
str(iris.wide)
str(iris.tidy)

# Think about which dataset you would use to get the plot shown right
# Fill in the ___ to produce the plot given to the right
ggplot(iris.tidy, aes(x = Species, y = Value, col = Part)) +
  geom_jitter() +
  facet_grid(. ~ Measure)

# Tidy work! Ggplots always want one measurement per row of the data frame.

```

## Variables to visuals, part 1b

In the last exercise you saw how iris.tidy was used to make a specific plot. It's important to know how to rearrange your data in this way so that your plotting functions become easier. In this exercise you'll use functions from the tidyr package to convert iris to iris.tidy.

The resulting iris.tidy data should look as follows:

```{r}
#      Species  Part Measure Value
#    1  setosa Sepal  Length   5.1
#    2  setosa Sepal  Length   4.9
#    3  setosa Sepal  Length   4.7
#    4  setosa Sepal  Length   4.6
#    5  setosa Sepal  Length   5.0
#    6  setosa Sepal  Length   5.4
#    ...
```

You can have a look at the iris dataset by typing head(iris) in the console.

Note: If you're not familiar with %>%, gather() and separate(), you may want to take the Cleaning Data in R course. In a nutshell, a dataset is called tidy when every row is an observation and every column is a variable. The gather() function moves information from the columns to the rows. It takes multiple columns and gathers them into a single column by adding rows. The separate() function splits one column into two or more columns according to a pattern you define. Lastly, the %>% (or "pipe") operator passes the result of the left-hand side as the first argument of the function on the right-hand side.

### Instructions

You'll use two functions from the tidyr package:

gather() rearranges the data frame by specifying the columns that are categorical variables with a - notation. Complete the command. Notice that only one variable is categorical in iris.
separate() splits up the new key column, which contains the former headers, according to .. The new column names "Part" and "Measure" are given in a character vector. Don't forget the quotes.

```{r}
# Load the tidyr package

head(iris)

# Fill in the ___ to produce to the correct iris.tidy dataset
iris.tidy <- iris %>%
  gather(key, Value, -Species) %>%
  separate(key, c("Part", "Measure"), "\\.")
```

## Variables to visuals, part 2

Here you'll take a look at another plot variant, shown at right. Which of your data frames would be used to produce this plot?

### Instructions

Look at the heads of iris, iris.wide and iris.tidy using head().
Fill in the ggplot function with the appropriate data frame and variable names. The names of the aesthetics of the plot will match with variable names in your dataset. The previous instruction will help you match variable names in datasets with the ones in the plot.

```{r}
# The 3 data frames (iris, iris.wide and iris.tidy) are available in your environment
# Execute head() on iris, iris.wide and iris.tidy (in that order)
head(iris)
head(iris.wide)
head(iris.tidy)

# Think about which dataset you would use to get the plot shown right
# Fill in the ___ to produce the plot given to the right
ggplot(iris.wide, aes(x = Length, y = Width, color = Part)) +
  geom_jitter() +
  facet_grid(. ~ Species)
```

## Variables to visuals, part 2b

In the last exercise you saw how iris.wide was used to make a specific plot. You also saw previously how you can derive iris.tidy from iris. Now you'll move on to produce iris.wide.

The head of the iris.wide should look like this in the end:

```{r}
#   Species  Part Length Width
#1  setosa Petal    1.4   0.2
#2  setosa Petal    1.4   0.2
#3  setosa Petal    1.3   0.2
#4  setosa Petal    1.5   0.2
#5  setosa Petal    1.4   0.2
#6  setosa Petal    1.7   0.4
#...
```
You can have a look at the iris dataset by typing head(iris) in the console.

### Instructions

Before you begin, you need to add a new column called Flower that contains a unique identifier for each row in the data frame. This is because you'll rearrange the data frame afterwards and you need to keep track of which row, or which specific flower, each value came from. It's done for you, no need to add anything yourself.
gather() rearranges the data frame by specifying the columns that are categorical variables with a - notation. In this case, Species and Flower are categorical. Complete the command.
separate() splits up the new key column, which contains the former headers, according to .. The new column names "Part" and "Measure" are given in a character vector.
The last step is to use spread() to distribute the new Measure column and associated value column into two columns.

```{r}
# Add column with unique ids (don't need to change)
iris$Flower <- 1:nrow(iris)

# Fill in the ___ to produce to the correct iris.wide dataset
iris.wide <- iris %>%
  gather(key, value, -Species, -Flower) %>%
  separate(key, c("Part", "Measure"), "\\.") %>%
  spread(Measure, value)
```

## All about aesthetics, part 1

In the video you saw 9 visible aesthetics. Let's apply them to a categorical variable - the cylinders in mtcars, cyl.

(You'll consider line type when you encounter line plots in the next chapter).

These are the aesthetics you can consider within aes() in this chapter: x, y, color, fill, size, alpha, labels and shape.

In the following exercise you can assume that the cyl column is categorical. It has already been transformed into a factor for you.

### Instructions

The mtcars data frame is available in your workspace. For each of the following four plots, use geom_point():

1 - Map mpg onto the x aesthetic, and cyl onto the y.
2 - Reverse the mappings of the first plot.
3 - Map wt onto x, mpg onto y, and cyl onto color.
Modify the previous plot by changing the shape argument of the geom to 1 and increase the size to 4. These are attributes that you should specify inside geom_point().

```{r}
# 1 - Map mpg to x and cyl to y
ggplot(mtcars, aes(x = mpg, y = cyl)) +
  geom_point()
  
# 2 - Reverse: Map cyl to x and mpg to y
ggplot(mtcars, aes(x = cyl, y = mpg)) +
  geom_point()

# 3 - Map wt to x, mpg to y and cyl to col
ggplot(mtcars, aes(x = wt, y = mpg, col=cyl)) +
  geom_point()

# 4 - Change shape and size of the points in the above plot
ggplot(mtcars, aes(x = wt, y = mpg, col = cyl)) +
  geom_point(shape=1, size=4)

```

## All about aesthetics, part 2

The color aesthetic typically changes the outside outline of an object and the fill aesthetic is typically the inside shading. However, as you saw in the last exercise, geom_point() is an exception. Here you use color, instead of fill for the inside of the point. But it's a bit subtler than that.

Which shape to use? The default geom_point() uses shape = 19 (a solid circle with an outline the same colour as the inside). Good alternatives are shape = 1 (hollow) and shape = 16 (solid, no outline). These all use the col aesthetic (don't forget to set alpha for solid points).

A really nice alternative is shape = 21 which allows you to use both fill for the inside and col for the outline! This is a great little trick for when you want to map two aesthetics to a dot.

What happens when you use the wrong aesthetic mapping? This is a very common mistake! The code from the previous exercise is in the editor. Using this as your starting point complete the instructions.

### Instructions

Note: In the mtcars dataset, cyl and am have been converted to factor for you.

1 - Copy & paste the first plot's code. Change the aesthetics so that cyl maps to fill rather than col.
2 - Copy & paste the second plot's code. In geom_point() change the shape argument to 21 and add an alpha argument set to 0.6.
3 - Copy & paste the third plot's code. In the ggplot() aesthetics, map am to col.

```{r}
# am and cyl are factors, wt is numeric
class(mtcars$am)
class(mtcars$cyl)
class(mtcars$wt)

# From the previous exercise
ggplot(mtcars, aes(x = wt, y = mpg, col = cyl)) +
  geom_point(shape = 1, size = 4)

# 1 - Map cyl to fill
ggplot(mtcars, aes(x = wt, y = mpg, fill = cyl)) +
  geom_point(shape = 1, size = 4)


# 2 - Change shape and alpha of the points in the above plot
ggplot(mtcars, aes(x = wt, y = mpg, fill = cyl)) +
  geom_point(shape = 21, size = 4, alpha=0.6)


# 3 - Map am to col in the above plot
ggplot(mtcars, aes(x = wt, y = mpg, fill = cyl, col = am)) +
  geom_point(shape = 21, size = 4, alpha=0.6)


# Shapely coding! Notice that mapping a categorical variable onto fill doesn't 
# change the colors, although a legend is generated! This is because the default 
# shape for points only has a color attribute and not a fill attribute! Use fill 
# when you have another shape (such as a bar), or when using a point that does 
# have a fill and a color attribute, such as shape = 21, which is a circle with 
# an outline. Any time you use a solid color, make sure to use alpha blending to 
# account for over plotting.
```

## All about aesthetics, part 3

Now that you've got some practice with incrementally building up plots, you can try to do it from scratch! The mtcars dataset is pre-loaded in the workspace.

### Instructions

Use ggplot() to create a basic scatter plot. Inside aes(), map wt onto x and mpg onto y. Typically, you would say "mpg described by wt" or "mpg vs wt", but in aes(), it's x first, y second. Use geom_point() to make three scatter plots:

cyl on size
cyl on alpha
cyl on shape
Try this last variant:

cyl on label. In order to correctly show the test (i.e. label), use geom_text().

```{r}
# Map cyl to size
ggplot(mtcars, aes(x = wt, y = mpg, size=cyl)) +
  geom_point()

# Map cyl to alpha
ggplot(mtcars, aes(x = wt, y = mpg, alpha=cyl)) +
  geom_point()

# Map cyl to shape 
ggplot(mtcars, aes(x = wt, y = mpg, shape=cyl)) +
  geom_point()

# Map cyl to label
ggplot(mtcars, aes(x = wt, y = mpg, label=cyl)) +
  geom_text()

# Nice! Which aesthetic do you think is the clearest for categorical data?
```

## All about attributes, part 1

In the video you saw that you can use all the aesthetics as attributes. Let's see how this works with the aesthetics you used in the previous exercises: x, y, color, fill, size, alpha, label and shape.

This time you'll use these arguments to set attributes of the plot, not aesthetics. However, there are some pitfalls you'll have to watch out for: these attributes can overwrite the aesthetics of your plot!

A word about shapes: In the exercise "All about aesthetics, part 2", you saw that shape = 21 results in a point that has a fill and an outline. Shapes in R can have a value from 1-25. Shapes 1-20 can only accept a color aesthetic, but shapes 21-25 have both a color and a fill aesthetic. See the pch argument in par() for further discussion.

A word about hexadecimal colours: Hexadecimal, literally "related to 16", is a base-16 alphanumeric counting system. Individual values come from the ranges 0-9 and A-F. This means there are 256 possible two-digit values (i.e. 00 - FF). Hexadecimal colours use this system to specify a six-digit code for Red, Green and Blue values ("#RRGGBB") of a colour (i.e. Pure blue: "#0000FF", black: "#000000", white: "#FFFFFF"). R can accept hex codes as valid colours.

### Instructions

1 - You will continue to work with mtcars. Use ggplot() to create a basic scatter plot: map wt onto x, mpg onto y and cyl onto color.
2 - Overwrite the color of the points inside geom_point() to my_color. Notice how this cancels out the colors given to the points by the number of cylinders!
3 - Starting with plot 2, map cyl to fill instead of col and set the attributes size to 10, shape to 23 and color to my_color inside geom_point().

```{r}
# Define a hexadecimal color
my_color <- "#4ABEFF"

# 1 - First scatter plot, with col aesthetic:
ggplot(mtcars, aes(x = wt, y=mpg, col=cyl)) +
  geom_point()


# 2 - Plot 1, but set col attributes in geom layer:
ggplot(mtcars, aes(x=wt, y=mpg, col=cyl)) +
  geom_point(color=my_color)


# 3 - Plot 2, with fill instead of col aesthetic, plut shape and size attributes in geom layer.
ggplot(mtcars, aes(x=wt, y=mpg, fill=cyl)) +
  geom_point(size=10, shape=23, color=my_color)

# Hunky-dory hex specs! Notice that if an aesthetic and an attribute are set 
# with the same argument, the attribute takes precedence. Once again, you see 
# that the attribute needs to match the shape and geom, the fill aesthetic 
# (or attribute) will only work with certain shapes.
```

## All about attributes, part 2

In the videos you saw that you can use all the aesthetics as attributes. Let's see how this works with the aesthetics you used in the previous exercises: x, y, color, fill, size, alpha, label and shape.

In this exercise you will set all kinds of attributes of the points!

You will continue to work with mtcars.

### Instructions

Add to the first command: draw points with alpha set to 0.5.
Add to the second command: draw points of shape 24 in the color yellow.
Add to the third command: draw text with label rownames(mtcars) in the color red. Don't use geom_point() here! You should get a scatter plot with the names of the cars instead of points.
Note: Remember to specify characters with quotation marks ("yellow", not yellow).

```{r}
# Expand to draw points with alpha 0.5
ggplot(mtcars, aes(x = wt, y = mpg, fill = cyl)) +
  geom_point(alpha=0.5)

  
# Expand to draw points with shape 24 and color yellow
ggplot(mtcars, aes(x = wt, y = mpg, fill = cyl)) + 
  geom_point(shape=24, color="yellow")

  
# Expand to draw text with label rownames(mtcars) and color red
ggplot(mtcars, aes(x = wt, y = mpg, fill = cyl)) +
  geom_text(label=rownames(mtcars), color="red")

# Awesome attribute assembling! Notice how ggplot2 lets you control these 
# different attributes.
```

## Going all out

In this exercise, you will gradually add more aesthetics layers to the plot. You're still working with the mtcars dataset, but this time you're using more features of the cars. For completeness, here is a list of all the features of the observations in mtcars:

mpg -- Miles/(US) gallon
cyl -- Number of cylinders
disp -- Displacement (cu.in.)
hp -- Gross horsepower
drat -- Rear axle ratio
wt -- Weight (lb/1000)
qsec -- 1/4 mile time
vs -- V/S engine.
am -- Transmission (0 = automatic, 1 = manual)
gear -- Number of forward gears
carb -- Number of carburetors

Notice that adding more aesthetics to your plot is not always a good idea. Adding aesthetic mappings to a plot will increase its complexity, and thus decrease its readability.

### Instructions

Note: In this chapter you saw aesthetics and attributes. Variables in a data frame are mapped to aesthetics in aes(). (e.g. aes(col = cyl)) within ggplot(). Visual elements are set by attributes in specific geom layers (geom_point(col = "red")). Don't confuse these two things - here you're focusing on aesthetic mappings.

Draw a scatter plot of mtcars with mpg on the x-axis, qsec on the y-axis and factor(cyl) as colors.
Expand the previous plot to include factor(am) as the shape of the points.
Expand the previous plot to include the ratio of horsepower to weight (i.e. (hp/wt)) as the size of the points.

```{r}
# Map mpg onto x, qsec onto y and factor(cyl) onto col
ggplot(mtcars, aes(x=mpg, y=qsec, col=factor(cyl))) +
  geom_point()

# Add mapping: factor(am) onto shape
ggplot(mtcars, aes(x=mpg, y=qsec, col=factor(cyl), shape=factor(am))) +
  geom_point()

# Add mapping: (hp/wt) onto size
ggplot(mtcars, aes(x=mpg, y=qsec, col=factor(cyl), shape=factor(am), size=(hp/wt))) +
  geom_point()

# That's a pretty slick plot! Between the x and y dimensions, the color, shape, 
# and size of the points, your plot displays five dimensions of the dataset!
```

## Position

You saw how jittering worked in the video, but bar plots suffer from their own issues of overplotting, as you'll see here. Use the "stack", "fill" and "dodge" positions to reproduce the plot in the viewer.

The ggplot2 base layers (data and aesthetics) have already been coded; they're stored in a variable cyl.am. It looks like this:

`cyl.am <- ggplot(mtcars, aes(x = factor(cyl), fill = factor(am)))`

### Instructions

Add a geom_bar() call to cyl.am. By default, the position will be set to "stack".
Fill in the second ggplot command. Explicitly set position to "fill" inside geom_bar().
Fill in the third ggplot command. Set position to "dodge".
The position = "dodge" version seems most appropriate. Finish off the fourth ggplot command by completing the three scale_ functions:
scale_x_discrete() takes as its only argument the x-axis label: "Cylinders".
scale_y_continuous() takes as its only argument the y-axis label: "Number".
scale_fill_manual() fixes the legend. The first argument is the title of the legend: "Transmission". Next, values and labels are set to predefined values for you. These are the colors and the labels in the legend.

```{r}
cyl.am <- ggplot(mtcars, aes(x = factor(cyl), fill = factor(am)))
# The base layer, cyl.am, is available for you
# Add geom (position = "stack" by default)
cyl.am + geom_bar(position="stack")

# Fill - show proportion
cyl.am + 
  geom_bar(position = "fill")  

# Dodging - principles of similarity and proximity
cyl.am +
  geom_bar(position = "dodge") 

# Clean up the axes with scale_ functions
val = c("#E41A1C", "#377EB8")
lab = c("Manual", "Automatic")
cyl.am +
  geom_bar(position = "dodge") +
  scale_x_discrete("Cylinders") + 
  scale_y_continuous("Number") +
  scale_fill_manual("Transmission", 
                    values = val,
                    labels = lab) 

# Premier positioning! Choosing the right position argument is an important part 
# of making a good plot.
```

## Setting a dummy aesthetic

In the last chapter you saw that all the visible aesthetics can serve as attributes and aesthetics, but I very conveniently left out x and y. That's because although you can make univariate plots (such as histograms, which you'll get to in the next chapter), a y-axis will always be provided, even if you didn't ask for it.

In the base package you can make univariate plots with stripchart() (shown in the viewer) directly and it will take care of a fake y axis for us. Since this is univariate data, there is no real y axis.

You can get the same thing in ggplot2, but it's a bit more cumbersome. The only reason you'd really want to do this is if you were making many plots and you wanted them to be in the same style, or you wanted to take advantage of an aesthetic mapping (e.g. colour).

### Instructions

Try to run ggplot(mtcars, aes(x = mpg)) + geom_point() in the console. x is only one of the two essential aesthetics for geom_point(), which is why you get an error message.
1 - To fix this, map a value, e.g. 0, instead of a variable, onto y. Use geom_jitter() to avoid having all the points on a horizontal line.
2 - To make everything look nicer, copy & paste the code for plot 1 and change the limits of the y axis using the appropriate scale_y_...() function. Set the limits argument to c(-2, 2).

```{r}
# 1 - Create jittered plot of mtcars, mpg onto x, 0 onto y
ggplot(mtcars, aes(x = mpg, y = 0)) +
  geom_jitter()

# 2 - Add function to change y axis limits
ggplot(mtcars, aes(x = mpg, y = 0)) +
  geom_jitter() +
  scale_y_continuous(limits = c(-2,2))

# Great work! The best way to make your plot depends on a lot of different 
# factors and sometimes ggplot2 might not be the best choice.
```

## Overplotting 1 - Point shape and transparency

In the previous section you saw that there are lots of ways to use aesthetics. Perhaps too many, because although they are possible, they are not all recommended. Let's take a look at what works and what doesn't.

So far you've focused on scatter plots since they are intuitive, easily understood and very common. A major consideration in any scatter plot is dealing with overplotting. You'll encounter this topic again in the geometries layer, but you can already make some adjustments here.

You'll have to deal with overplotting when you have:

Large datasets,
Imprecise data and so points are not clearly separated on your plot (you saw this in the video with the iris dataset),
Interval data (i.e. data appears at fixed values), or
Aligned data values on a single axis.
One very common technique that I'd recommend to always use when you have solid shapes it to use alpha blending (i.e. adding transparency). An alternative is to use hollow shapes. These are adjustments to make before even worrying about positioning. This addresses the first point as above, which you'll see again in the next exercise.

### Instructions

Begin by making a basic scatter plot of mpg (y) vs. wt (x), map cyl to color and make the size = 4. cyl has already been converted to a factor variable for you.
Modify the above plot to set shape to 1. This allows for hollow circles.
Modify the first plot to set alpha to 0.6.

```{r}
# Basic scatter plot: wt on x-axis and mpg on y-axis; map cyl to col
ggplot(mtcars, aes(x=wt, y=mpg, col=cyl)) + 
  geom_point(size=4)

# Hollow circles - an improvement
ggplot(mtcars, aes(x=wt, y=mpg, col=cyl)) + 
  geom_point(size=4, shape=1)

# Add transparency - very nice
ggplot(mtcars, aes(x=wt, y=mpg, col=cyl)) + 
  geom_point(size=4, shape=1, alpha=0.6)

# Good job! By now you should understand why solid shapes are not really useful.
```

## Overplotting 2 - alpha with large datasets

In a previous exercise we defined four situations in which you'd have to adjust for overplotting. You'll consider the last two here with the diamonds dataset:

1. Large datasets.
2. Aligned data values on a single axis

### Instructions

The diamonds data frame is available in the ggplot2() package. Begin by making a basic scatter plot of price (y) vs. carat (x) and map clarity onto color.
Copy the above functions and set the alpha to 0.5. This is a good start to dealing with the large dataset.
Align all the diamonds within a clarity class, by plotting carat (y) vs. clarity (x). Map price onto color. alpha should still be 0.5.
In the previous plot, all the individual values line up on a single axis within each clarity category, so you have not overcome overplotting. Modify the above plot to use the position = "jitter" inside geom_point().

```{r}
# Scatter plot: carat (x), price (y), clarity (color)
ggplot(diamonds, aes(x=carat, y=price, col=clarity)) +
  geom_point()


# Adjust for overplotting
ggplot(diamonds, aes(x=carat, y=price, col=clarity)) +
  geom_point(alpha=0.5)


# Scatter plot: clarity (x), carat (y), price (color)
ggplot(diamonds, aes(x=clarity, y=carat, col=price)) +
  geom_point(alpha=0.5)


# Dot plot with jittering
ggplot(diamonds, aes(x=clarity, y=carat, col=price)) +
  geom_point(alpha=0.5, position="jitter")

# Tantalizing transparency! These are some simple ways of dealing with large 
# datasets, but you'll encounter more ideas in the geom chapter and in the 
# advanced course on ggplot2 when you look at atypical geoms.

# You have finished the chapter "Aesthetics"!
```

