---
title: "Data Analytics and Visualizations in R - Exercises"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
    number_sections: true
    theme: lumen
    highlight: tango
    code_folding: show
    keep_md: true
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
---

# Basic R Data Structures

***

## Types

What are the scalar types in R?

```{r}
# Scalars are just vectors of length one
```


## Weirdness of R

What is the major difference between atomic vectors and lists? How can you turn a list into an atomic vector?

In order to check if an object is of a certain type you can use `is.[type](object)` ,e.g. `is.integer(object)`

Can you use the `is.vector()` function to understand whether a data structure is a vector? If
not, what are the functions that you can use for this purpose?

```{r}
# Atomic vectors can contain elements of the same type. The elements of a list 
# can have different types.

# Yes, we can use the `is.vector()` function to understand is the structure is a 
# vector. It will return TRUE or FALSE.

a <- list(c(1,2,3), "bla", TRUE)
print(a)
is.vector(a)

# Best response: If possible you should use type specific coercions like 
# `as.numeric()` or `as.character()`. But since lists are heterogenous, this 
# might not work. A more general function is `unlist()`,  which returns the list 
# into a vector of the most general type. Notice this difference:

a <- list(c(1,2,3), "bla", TRUE)
unlist(a)
as.character(a)

# Generally you can, but here comes the weird part: `is.vector()` will only return `TRUE` if the vector has 
# no attributes `names`. Therefore more specific functions like `is.atomic()` or `is.list()` functions should 
# be used to test if an object is actually atomic vectoror a list
```


## Atomic Vector Concatenation

What happens when you try to generate an atomic vector with `c()`which is composed of different types of elements? What is the `mean()` 
of a logical vector?

```{r}
# When we attempt to combine different types they will be coerced to the most 
# flexible type. Types from least to most flexible are: logical, integer, double
#  and character.

str(c("a", 1)) # 1 corced to char

# As TRUE is encoded as 1 and FALSE as 0, the mean is the number of TRUEs 
# devided by the vector length.
mean(c(TRUE, FALSE,FALSE))
```


## Vector Concatenation

Compare X and Y where X and Y are defined as follows. What is the difference?

```{r}
x <- list(list(1,2), c(3,4))
y <- c(list(1,2), c(3,4))
```

```{r}
# Answer
# X will combine seveal lists into one. Given a combination of atomic vectors 
# and lists, y will coerce the vectors to lists before combining them.
str(x)
str(y)
```

## From Vectors to `data.frames`

First, create three named numeric vectors of size 10, 11 and 12 respectively in the following
manner:

* One vector with the “colon” approach: *from:to*
* One vector with the `seq()` function: *seq(from, to)*
* And one vector with the `seq()` function and the by argument: *seq(from, to, by)*

For easier naming you can use the vector `letters` or `LETTERS` which contain the latin alphabet
in small and capital, respectively. In order to select specific letters just use e.g. `letters[1:4]`
to get the first four letters. 
Check their types. What is the outcome? Where do you think does the difference come from?

Then combine all three vectors in a list. Check the attributes of the vectors and the list.
What is the difference and why?

Finally coerce the list to a `data.frame` with `as.data.frame()`. Why does it fail and how can we fix it? 
What happend to the names?

Hint: If list elements have no names, we can access them with the double brackets and an
index, e.g. `my_list[[1]]`

```{r}
# Answer

# A. create vectors
aa <- 1:10
names(aa) <- letters[aa]
aa
bb <- seq(1, 11)
names(bb) <- letters[bb]
bb
cc <- seq(1, 12, by=1)
names(cc) <- letters[cc]

typeof(aa)
typeof(bb)
typeof(cc)

# B. Combine all three vectors in a list
 
my_list <- list(aa, bb, cc)
my_list
attributes(aa)
attributes(bb)
attributes(cc)
attributes(my_list)

# C. Coerce to data.frames

# my_df <- as.data.frame(my_list)# fails

# Fixing the length
my_list[[1]] <- c(my_list[[1]], NA, NA)
my_list[[2]] <- c(my_list[[2]], NA)

my_df <- as.data.frame(my_list)
names(my_df) <- LETTERS[1:3]
my_df
```

## Attributes
Take again our `data.frame` from Question 5.

* Change the row names and the column names of the `data.frame` to capital letters (or small letters, if they 
are already capital.
* Change the `class` attribute to *list*. What happens?
* Change it now to any name you like. What happens now? What happens if you remove the class attribute

```{r}
# Answer
# A. One possible way through attributes

attributes(my_df)
attr(my_df, "names") <- letters[1:3]
attr(my_df, "row.names") <- LETTERS[1:12]
my_df

# Or through accessor functions

names(my_df) <- LETTERS[1:3]
row.names(my_df) <- letters[1:12]
my_df

# B. 

attr(my_df, "class") <- "list"
my_df

# Answer - the data.frame coerced to a list

# C
attr(my_df, "class") <- "Batman"
my_df

# Answer - Nothing changes
```

## Factors

* What is the difference between a Factor and a Vector?
* Create a vector of length 30 with three levels *Rita Repulsa, Lord Zedd* and *Rito Revolto* and equal length for each level
* What happens if you replace the second element of the vector with *Shredder*

```{r}
# Answer
# A. A factor is a vector that can contain only predefined values, and is used 
# to store categorical data. It is stored as an integer with a character string 
# associated with each integer value

# B.

x <- gl(n=3, k=10, length=30, labels=c("Rita Repulsa", "Lord Zedd", "Rito Revolto"))
str(x)
levels(x)
attributes(x)

# C
x[2] <- "Shredder"
# It doesn't work. We get the error 'NA generated'
```

## More fun with factors

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
f2 <- rev(factor(letters))
f3 <- factor(letters, levels = rev(letters))
```

The function `rev` reverses the order of an orderable object. What is the difference between f1, f2 and f3? Why?

```{r}
# Answer
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

# f1 goes from a to z and when we apply the levels(f1), z will become 1 and a=26

f2 <- rev(factor(letters))

# f2 goes from z to a. but the levels are not changed.

f3 <- factor(letters, levels = rev(letters))

# f3 goes from a - z, but the underlying encoding goes from z = 1 to a = 26.  
# We create the vector with the letters a to z BUT the mapped integer structure 
# 26 to 1. Hence the levels but not the vector are reversed

f3

# Reversing f3 will give f1

rev(f3)

```

## Creating data.frames

Create a data.frame with 26 rows like this: Only the first and the last six rows are shown.
Hint: Instead of the workaround with list you can also use simply `data.frame(column_name
= column_vector, ...)`

```{r}
aa <- seq(1:26)
bb <- seq(from=4, to=4*26, by=4)
cc <- rep(seq(1, 26, 2), each=2)
df <- data.frame(V1 = aa, V2 = bb, V3 = letters[cc])
head(df)
tail(df)
```

## Combining `data.frames`

Now take the previous data.frame from Question 10 and reproduce the following `data.frame`.
Only the first and the last six rows are shown
**Hint:** In order to combine to data.frames by column you can use `cbind(df1, df2, ...)`

help(cbind)
```{r}
df[,1] <- NULL
dd <- rev(rep(seq(1, 26, 2), each = 2))
ee <- seq(0, 1.6, length.out = 26)
df2 <- data.frame(V4 = dd, V5 = ee)
binded_df <- cbind(df2, df)
head(binded_df)
tail(binded_df)
```

## Computation on data.frames

Create the data.frame *df* with `df <- as.data.frame(matrix(runif(9e6), 3e3, 3e3))`
This will create a data.frame with 3000 columns and rows and a total of 9mil values.

Now compute the sum of any row, then compute the sum of any column. Measure the time
for both operations. Why are the times different, although the size is the same?

* **Hint1:** The time is measured with the function `system.time(my_function_call())`, e.g: `system.time(mean(my_vector))`
* **Hint2:** The sum can be computed with the sum function `sum(my_vector)`
* **Hint2:** Columns and rows are selected by single brackets. Rows: `df[row_number,]`, Columns: `df[,col_number]`

```{r}
# Answer

df <- as.data.frame(matrix(runif(9e6), 3e3, 3e3))

# rows
system.time(res <- sum(df[1,]))
res

# columngs
system.time(res2 <- sum(df[,1]))
res2

# Look at the structure of the objects over which we are computing the sum
# Column
str(df[1,])

# Row
str(df[,1])

# As we can see the extracted column is a numeric vector. But the extracted
# row is a list. Under the hood the sum function is iterating in C/Fortran
# over the specific structure. Iterating over a native array of doubles is
# faster, than iterating over a structure, where at each position, the value
# has to be retrieved from an object possibly strored somewhere further away
# in memory.
```

## Missing Values

* If NA is just a placeholder for a missing value of the same type and Infinity is of type
double, why is Infinity plus NA not Infinity?

**Hint:**
```{r}
paste(paste(rep((Inf - Inf), 20), collapse = ""), "Batman!")
```

```{r}
# Answer:
# Because infinity is not a well defined number, but a concept with
# the type 'double' in R. Adding or subtracting any number from infinity
# will give infinity. However NA is placeholder for any value of the same
# type and therefore also for infinity. As infinity plus/minus infinity
# is not defined, adding NA to infinity can theoretically lead to
# Nan (not a number). Therefore Inf + NA will produce NA.

Inf + NA
Inf + 1
Inf - Inf
```

---

# Advanced R Data Structures and Mathematical Operations

## Basic data structures

How would you create a 3 by 4 matrix that contains the numbers 1 to 12 and then convert it into a data frame?

```{r}
# Answer

x <- matrix(1:12, 3,4)
x <- as.data.frame(x)
x
```

