---
title: "Data Analytics and Visualizations in R - Exercises"
output:
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
    number_sections: true
    theme: lumen
    highlight: tango
    code_folding: show
    keep_md: true
---

# Basic R Data Structures

***

## Types

What are the scalar types in R?

```{r}
# Scalars are just vectors of length one
```


## Weirdness of R

What is the major difference between atomic vectors and lists? How can you turn a list into an atomic vector?

In order to check if an object is of a certain type you can use `is.[type](object)` ,e.g. `is.integer(object)`

Can you use the `is.vector()` function to understand whether a data structure is a vector? If
not, what are the functions that you can use for this purpose?

```{r}
# Atomic vectors can contain elements of the same type. The elements of a list can have different types.

# Yes, we can use the `is.vector()` function to understand is the structure is a vector. 
# It will return TRUE or FALSE.

a <- list(c(1,2,3), "bla", TRUE)
print(a)
is.vector(a)

# Best response: If possible you should use type specific coercions like `as.numeric()` or `as.character()`. 
# But since lists are heterogenous, this might not work. A more general function is `unlist()`, 
# which returns the list into a vector of the most general type. Notice this difference:

a <- list(c(1,2,3), "bla", TRUE)
unlist(a)
as.character(a)

# Generally you can, but here comes the weird part: `is.vector()` will only return `TRUE` if the vector has 
# no attributes `names`. Therefore more specific functions like `is.atomic()` or `is.list()` functions should 
# be used to test if an object is actually atomic vectoror a list
```


## Atomic Vector Concatenation

What happens when you try to generate an atomic vector with `c()`which is composed of different types of elements? What is the `mean()` 
of a logical vector?

```{r}
# When we attempt to combine different types they will be coerced to the most flexible type. Types from least
# to most flexible are: logical, integer, double and character.

str(c("a", 1)) # 1 corced to char

# As TRUE is encoded as 1 and FALSE as 0, the mean is the number of TRUEs devided by the vector length.
mean(c(TRUE, FALSE,FALSE))
```


## Vector Concatenation

Compare X and Y where X and Y are defined as follows. What is the difference?

```{r}
x <- list(list(1,2), c(3,4))
y <- c(list(1,2), c(3,4))
```

```{r}
# Answer
# X will combine seveal lists into one. Given a combination of atomic vectors and lists, y will coerce the 
# vectors to lists before combining them.
str(x)
str(y)
```

## From Vectors to `data.frames`

First, create three named numeric vectors of size 10, 11 and 12 respectively in the following
manner:

* One vector with the “colon” approach: *from:to*
* One vector with the `seq()` function: *seq(from, to)*
* And one vector with the `seq()` function and the by argument: *seq(from, to, by)*

For easier naming you can use the vector `letters` or `LETTERS` which contain the latin alphabet
in small and capital, respectively. In order to select specific letters just use e.g. `letters[1:4]`
to get the first four letters. 
Check their types. What is the outcome? Where do you think does the difference come from?

Then combine all three vectors in a list. Check the attributes of the vectors and the list.
What is the difference and why?

Finally coerce the list to a `data.frame` with `as.data.frame()`. Why does it fail and how can we fix it? 
What happend to the names?

Hint: If list elements have no names, we can access them with the double brackets and an
index, e.g. `my_list[[1]]`

```{r}
# Answer

# A. create vectors
aa <- 1:10
names(aa) <- letters[aa]
aa
bb <- seq(1, 11)
names(bb) <- letters[bb]
bb
cc <- seq(1, 12, by=1)
names(cc) <- letters[cc]

typeof(aa)
typeof(bb)
typeof(cc)

# B. Combine all three vectors in a list
 
my_list <- list(aa, bb, cc)
my_list
attributes(aa)
attributes(bb)
attributes(cc)
attributes(my_list)

# C. Coerce to data.frames

# my_df <- as.data.frame(my_list)# fails

# Fixing the length
my_list[[1]] <- c(my_list[[1]], NA, NA)
my_list[[2]] <- c(my_list[[2]], NA)

my_df <- as.data.frame(my_list)
names(my_df) <- LETTERS[1:3]
my_df
```

## Attributes
Take again our `data.frame` from Question 5.

* Change the row names and the column names of the `data.frame` to capital letters (or small letters, if they 
are already capital.
* Change the `class` attribute to *list*. What happens?
* Change it now to any name you like. What happens now? What happens if you remove the class attribute

```{r}
# Answer
# A. One possible way through attributes

attributes(my_df)
attr(my_df, "names") <- letters[1:3]
attr(my_df, "row.names") <- LETTERS[1:12]
my_df

# Or through accessor functions

names(my_df) <- LETTERS[1:3]
row.names(my_df) <- letters[1:12]
my_df

# B. 

attr(my_df, "class") <- "list"
my_df

# Answer - the data.frame coerced to a list

# C
attr(my_df, "class") <- "Batman"
my_df

# Answer - Nothing changes
```

## Factors

* What is the difference between a Factor and a Vector?
* Create a vector of length 30 with three levels *Rita Repulsa, Lord Zedd* and *Rito Revolto* and equal length for each level
* What happens if you replace the second element of the vector with *Shredder*

```{r}
# Answer
# A. A factor is a vector that can contain only predefined values, and is used to store categorical data.
# It is stored as an integer with a character string associated with each integer value

# B.

x <- gl(n=3, k=10, length=30, labels=c("Rita Repulsa", "Lord Zedd", "Rito Revolto"))
str(x)
levels(x)
attributes(x)

# C
x[2] <- "Shredder"
# It doesn't work. We get the error 'NA generated'
```

## More fun with factors

```{r}
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))
f2 <- rev(factor(letters))
f3 <- factor(letters, levels = rev(letters))
```

The function `rev` reverses the order of an orderable object. What is the difference between f1, f2 and f3? Why?

```{r}
# Answer
f1 <- factor(letters)
levels(f1) <- rev(levels(f1))

# f1 goes from a to z and when we apply the levels(f1), z will become 1 and a = 26

f2 <- rev(factor(letters))

# f2 goes from z to a. but the levels are not changed.

f3 <- factor(letters, levels = rev(letters))

# f3 goes from a - z, but the underlying encoding goes from z = 1 to a = 26.  We create the vector with the 
# letters a to z BUT the mapped integer structure 26 to 1. Hence the levels but not the vector are reversed

f3

# Reversing f3 will give f1

rev(f3)

```

