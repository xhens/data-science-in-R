---
title: "Data Analytics and Visualizations in R - Exercises"
output:
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
    number_sections: true
    theme: lumen
    highlight: tango
    code_folding: show
    keep_md: true
---

# Basic R Data Structures

***

## Types

What are the scalar types in R?

```{r}
# Scalars are just vectors of length one
```


## Weirdness of R

What is the major difference between atomic vectors and lists? How can you turn a list into an atomic vector?

In order to check if an object is of a certain type you can use `is.[type](object)` ,e.g. `is.integer(object)`

Can you use the `is.vector()` function to understand whether a data structure is a vector? If
not, what are the functions that you can use for this purpose?

```{r}
# Atomic vectors can contain elements of the same type. The elements of a list can have different types.

# Yes, we can use the `is.vector()` function to understand is the structure is a vector. 
# It will return TRUE or FALSE.

a <- list(c(1,2,3), "bla", TRUE)
print(a)
is.vector(a)

# Best response: If possible you should use type specific coercions like `as.numeric()` or `as.character()`. 
# But since lists are heterogenous, this might not work. A more general function is `unlist()`, 
# which returns the list into a vector of the most general type. Notice this difference:

a <- list(c(1,2,3), "bla", TRUE)
unlist(a)
as.character(a)

# Generally you can, but here comes the weird part: `is.vector()` will only return `TRUE` if the vector has 
# no attributes `names`. Therefore more specific functions like `is.atomic()` or `is.list()` functions should 
# be used to test if an object is actually atomic vectoror a list
```


## Atomic Vector Concatenation

What happens when you try to generate an atomic vector with `c()`which is composed of different types of elements? What is the `mean()` 
of a logical vector?

```{r}
# When we attempt to combine different types they will be coerced to the most flexible type. Types from least
# to most flexible are: logical, integer, double and character.

str(c("a", 1)) # 1 corced to char

# As TRUE is encoded as 1 and FALSE as 0, the mean is the number of TRUEs devided by the vector length.
mean(c(TRUE, FALSE,FALSE))
```


## Vector Concatenation

Compare X and Y where X and Y are defined as follows. What is the difference?

```{r}
x <- list(list(1,2), c(3,4))
y <- c(list(1,2), c(3,4))
```

```{r}
# Answer
# X will combine seveal lists into one. Given a combination of atomic vectors and lists, y will coerce the 
# vectors to lists before combining them.
str(x)
str(y)
```

## From Vectors to `data.frames`

First, create three named numeric vectors of size 10, 11 and 12 respectively in the following
manner:

* One vector with the “colon” approach: *from:to*
* One vector with the `seq()` function: *seq(from, to)*
* And one vector with the `seq()` function and the by argument: *seq(from, to, by)*

For easier naming you can use the vector `letters` or `LETTERS` which contain the latin alphabet
in small and capital, respectively. In order to select specific letters just use e.g. `letters[1:4]`
to get the first four letters. 
Check their types. What is the outcome? Where do you think does the difference come from?

Then combine all three vectors in a list. Check the attributes of the vectors and the list.
What is the difference and why?

Finally coerce the list to a `data.frame` with `as.data.frame()`. Why does it fail and how can we fix it? 
What happend to the names?

Hint: If list elements have no names, we can access them with the double brackets and an
index, e.g. `my_list[[1]]`

```{r}
# Answer

# A. create vectors
aa <- 1:10
names(aa) <- letters[aa]
aa
bb <- seq(1, 11)
names(bb) <- letters[bb]
bb
cc <- seq(1, 12, by=1)
names(cc) <- letters[cc]

typeof(aa)
typeof(bb)
typeof(cc)

# B. Combine all three vectors in a list
 
my_list <- list(aa, bb, cc)
my_list
attributes(aa)
attributes(bb)
attributes(cc)
attributes(my_list)

# C. Coerce to data.frames

# my_df <- as.data.frame(my_list)# fails

# Fixing the length
my_list[[1]] <- c(my_list[[1]], NA, NA)
my_list[[2]] <- c(my_list[[2]], NA)

my_df <- as.data.frame(my_list)
names(my_df) <- LETTERS[1:3]
my_df
```

## Attributes
Take again our `data.frame` from Question 5.

* Change the row names and the column names of the `data.frame` to capital letters (or small letters, if they 
are already capital.
* Change the `class` attribute to *list*. What happens?
* Change it now to any name you like. What happens now? What happens if you remove the class attribute

```{r}
# Answer
# A. One possible way through attributes

attributes(my_df)
attr(my_df, "names") <- letters[1:3]
attr(my_df, "row.names") <- LETTERS[1:12]
my_df

# Or through accessor functions

names(my_df) <- LETTERS[1:3]
row.names(my_df) <- letters[1:12]
my_df

# B. 

attr(my_df, "class") <- "list"
my_df

# Answer - the data.frame coerced to a list

# C
attr(my_df, "class") <- "Batman"
my_df

# Answer - Nothing changes
```

